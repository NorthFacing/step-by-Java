# 第五章：链表
* 链结点
* 单链表
* 查找和删除指定链结点
* 双端链结点
* 链表的效率
* 抽象数据类型
* 有序链表
* 双向链表
* 迭代器


# 01.链结点
一个链结点是某个类的对象，这个类可以叫做Link。每个Link对象都包含一个对下一个链结
点引用的字段（通常叫做next）。但是链表本身的对象中有一个字段指向对第一个链结点的
引用。

* 关系而不是位置

# 02.单链表
范例：linkList

# 03.查找和删除指定链结点
范例：linkList2
需要从链表开始的地方遍历，一直找到匹配的元素为止

# 04.双端链结点
范例：firstLastList
* 增加了一个last属性，链接到最末尾的元素
* 增加了一个addLast方法，可以直接将新元素增加到末尾
* 但是依然不能直接删除最后一个节点，因为没有元素指向倒数第二个节点

# 05.链表的效率
* 在表头操作速度很快，花费时间：O(1)
* 平均起来，查找、删除和在指定链结点后面插入都需要O(N)次比较。但比数组操作要快，特别是复制时间远大于比较时间时
* 链表的另外一个好处是，需要多少内存就使用多少内存，并且可以扩展到所有内存。而数组在初始化的时候就固定了。

# 06.抽象数据类型 —— ADT
简单来说，他是一种考虑数据结构的方式：着重于它做了什么，而忽略它是怎么做的。
Bob：类似于接口的定义。

范例：linkQueue、linkStack
没有自己用链表实现栈和队列，后面复习的时候可以补上。


# 07.有序链表

有序链表优于数组的地方

* 在于插入速度快
* 链表可以扩展到全部有效的使用内存

链表的应用：

* 为数据排序
* 用于实现优先级队列（尽管堆是更常用的实现方法，参考第12章）

范例：sortedList
插入的时候进行比较之后进行插入。

# 08.双向链表
双向列表保存了两个属性，元素的前一个元素以及后一个元素。
这样不仅能够从前往后找，也可以从后往前找。
范例：doublyLinked

# 09.迭代器
范例：interIterator


# 小结
* 链表包含一个linkedList对象和许多Link对象
* linkedList对象包含一个引用，这个引用通常叫做first，它指向链表的第一个链结点
* 每个Link对象包含数据和一个引用，通常叫做next，它指向链表的下一个链结点
* next字段为null，意味着链表的结尾
* 在表头插入链结点需要把新链结点的next字段指向原来的第一个链结点，然后把first指向新链结点
* 在表头删除链结点，要把first指向first.next
* 为了遍历链表，从first开始，根据链结点的next字段找到下一个连接点
* 通过遍历链表可以找到拥有特定值的链结点，一旦找到，可以进行显示、删除或其他操作
* 新链结点可以插在某个特定值的链结点的前面或者后面，但是前提是先遍历找到这个链结点
* 双端列表在链表中维护一个指向最后一个链结点的引用，它通常和first一样，叫做last
* 双端列表运行在链表的表尾插入数据项（但是不能删除）
* 抽象数据类型（ADT）是一种数据存储类，不涉及它的实现
* 栈和队列是ADT，它们既可以用数组实现，又可以用链表实现
* 有序列表中，链结点按照关键值升序（有时是降序）排列
* 在有序链表中插入需要O(N)的时间，因为必须找到正确的插入点。最小值链结点的删除需要O(1)的时间
* 双向链表中，每个链结点包含对前一个链结点的引用，同时有对后一个链结点的引用
* 双向链表允许反向遍历，并可以从表尾删除
* 迭代器是一个引用，它被封装在类对象中，这个引用指向相关联的链表中的链结点
* 迭代器方法允许使用者沿链表移动迭代器，并访问当前指示的链结点
* 能用迭代器遍历链表，在选定的链结点（或所有链结点）上执行某些操作





