# 第二章 线程安全

编写线程安全的代码，本质上就是管理对状态的访问，而且通常都是共享的、可变的状态。
通俗的说，一个对象的状态就是它的数据，存储在状态变量中，比如实例域或静态域。
无论何时，只要有多于一个的线程访问给定的状态变量，而且其中某个线程会写入该变量，
此时必须使用同步来协调线程对该变量的访问。

## 2.1 什么是线程安全

无状态对象：不包含域也没有引用其他类型的域。一次特定计算的瞬时状态，会唯一地存在本地变量中，
这些本地变量存储在线程的栈中，只有执行线程才能访问。所以无状态对象永远是线程安全的。

## 2.2 原子性

check-then-act 检查再运行的情况也可能出现非线程安全的状况，比如惰性单例实例化。
非原子性操作的时候都会出现竞争条件。

## 2.3 锁

内部锁：synchronize，是一个独占锁，

重进入：重进入意味着请求是基于“每一个线程”，而不是基于“每一次调用”。

https://segmentfault.com/a/1190000012182774
http://www.jianshu.com/p/007bd7029faf


## 用锁来保护状态
## 活跃度与性能